---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pipeline/package.json
  - pipeline/tsconfig.json
  - pipeline/vitest.config.ts
  - pipeline/src/types/pipeline.ts
  - pipeline/src/types/manga.ts
  - pipeline/src/types/index.ts
  - pipeline/src/config/paths.ts
  - pipeline/src/config/defaults.ts
  - pipeline/src/utils/fs.ts
  - pipeline/src/cli.ts
  - pipeline/src/stages/script.ts
  - pipeline/src/stages/prompt.ts
  - pipeline/src/stages/generate.ts
  - pipeline/src/stages/overlay.ts
  - pipeline/src/stages/assemble.ts
  - pipeline/tests/config/paths.test.ts
  - pipeline/tests/stages/script.test.ts
  - pipeline/tests/utils/fs.test.ts
  - .gitignore
autonomous: true
requirements:
  - INFR-01
  - INFR-02
  - INFR-03
  - INFR-04
  - INFR-05

must_haves:
  truths:
    - "Running `pnpm tsx src/cli.ts --help` inside pipeline/ prints usage with all 5 stage subcommands listed"
    - "Running `pnpm tsx src/cli.ts script -c 1` prints a stub message and exits 0 (same for all 5 stages)"
    - "Running `pnpm run test:run` inside pipeline/ passes all tests with 0 failures"
    - "Path resolution tests confirm 01_bible/ and 03_manga/ resolve to real existing directories"
    - "Pipeline code exists entirely within pipeline/ with its own package.json (decoupled from project root)"
    - "output/ directory is gitignored and no pipeline stage writes to 01_bible/ or 03_manga/"
  artifacts:
    - path: "pipeline/package.json"
      provides: "pnpm project with commander, sharp, tsx, typescript, vitest"
      contains: "type.*module"
    - path: "pipeline/tsconfig.json"
      provides: "Strict TypeScript config for Node.js 20 ESM"
      contains: "strict.*true"
    - path: "pipeline/vitest.config.ts"
      provides: "Vitest test configuration"
      contains: "defineConfig"
    - path: "pipeline/src/cli.ts"
      provides: "Commander CLI entry point with 5 stage subcommands"
      contains: "program.command"
    - path: "pipeline/src/config/paths.ts"
      provides: "Centralized path resolution for read-only source dirs and output dir"
      contains: "PATHS"
    - path: "pipeline/src/types/pipeline.ts"
      provides: "StageResult and StageOptions interfaces"
      contains: "StageResult"
    - path: "pipeline/src/stages/script.ts"
      provides: "Script stage stub returning StageResult"
      contains: "runScript"
    - path: "pipeline/tests/config/paths.test.ts"
      provides: "Path resolution tests proving source dirs exist"
      contains: "existsSync"
  key_links:
    - from: "pipeline/src/cli.ts"
      to: "pipeline/src/stages/*.ts"
      via: "dynamic import in commander action handlers"
      pattern: "await import.*stages/"
    - from: "pipeline/src/stages/*.ts"
      to: "pipeline/src/types/pipeline.ts"
      via: "typed StageOptions input and StageResult return"
      pattern: "import type.*StageResult"
    - from: "pipeline/src/stages/*.ts"
      to: "pipeline/src/config/paths.ts"
      via: "PATHS import for directory resolution"
      pattern: "import.*PATHS.*config/paths"
    - from: "pipeline/tests/config/paths.test.ts"
      to: "pipeline/src/config/paths.ts"
      via: "import and assert real filesystem paths"
      pattern: "existsSync.*PATHS"
---

<objective>
Set up the complete TypeScript pipeline project with CLI, stage scaffolding, path resolution, shared types, and test infrastructure.

Purpose: Establish the foundation that all subsequent pipeline phases (scripting, prompt generation, image workflow, assembly) build upon. Every future stage implementation slots into the scaffold created here.

Output: A working `pipeline/` TypeScript project where `pnpm tsx src/cli.ts <stage> -c 1` runs any of the 5 stage stubs, `pnpm run test:run` passes, and all source directories resolve correctly.
</objective>

<execution_context>
@/Users/dondemetrius/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dondemetrius/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize pipeline project with pnpm, TypeScript strict, and dependencies</name>
  <files>
    pipeline/package.json
    pipeline/tsconfig.json
    pipeline/vitest.config.ts
    .gitignore
  </files>
  <action>
Create the `pipeline/` directory and initialize the project:

1. Create `pipeline/` directory at project root.

2. Write `pipeline/package.json` with these exact settings:
   - `"name": "plasma-pipeline"`, `"version": "0.1.0"`, `"type": "module"`
   - scripts: `dev`, `build` (tsc), `typecheck` (tsc --noEmit), `test` (vitest), `test:run` (vitest run), and `stage:script`, `stage:prompt`, `stage:generate`, `stage:overlay`, `stage:assemble` (each running `tsx src/cli.ts <stage>`)
   - dependencies: `commander` (^14.0.3), `sharp` (^0.34.5)
   - devDependencies: `@types/node` (^20.0.0), `tsx` (^4.21.0), `typescript` (~5.7.0), `vitest` (^4.0.18)
   - Use the exact package.json pattern from research (01-RESEARCH.md Code Examples section)

3. Write `pipeline/tsconfig.json` with strict TypeScript ESM config:
   - target: es2022, module: NodeNext, moduleResolution: NodeNext
   - strict: true, noUncheckedIndexedAccess: true, noImplicitOverride: true
   - verbatimModuleSyntax: true, isolatedModules: true
   - outDir: dist, rootDir: src, sourceMap: true
   - Use the exact tsconfig pattern from research

4. Write `pipeline/vitest.config.ts`:
   - globals: true, include: tests/**/*.test.ts
   - coverage provider: v8, include src/**/*.ts, exclude src/cli.ts
   - Use the exact vitest config pattern from research

5. Create `.gitignore` at project root with:
   - `output/` (generated manga images)
   - `pipeline/node_modules/`
   - `pipeline/dist/`
   - `*.DS_Store`

6. Run `pnpm install` inside `pipeline/` to install all dependencies.

7. Verify Sharp works by running: `cd pipeline && pnpm tsx -e "import sharp from 'sharp'; console.log('Sharp OK:', sharp.versions)"`

8. Create empty directory stubs: `pipeline/src/stages/`, `pipeline/src/types/`, `pipeline/src/config/`, `pipeline/src/utils/`, `pipeline/tests/stages/`, `pipeline/tests/config/`, `pipeline/tests/utils/`

IMPORTANT: Do NOT create `pnpm-workspace.yaml` anywhere. This is a standalone package, not a monorepo.
IMPORTANT: package.json MUST have `"type": "module"` for ESM.
  </action>
  <verify>
Run from project root:
- `cd pipeline && pnpm tsx -e "import sharp from 'sharp'; console.log('Sharp OK:', sharp.versions)"` prints version info
- `cd pipeline && pnpm run typecheck` exits 0 (will pass once tsconfig is valid, even with no source files yet -- tsc --noEmit on empty src is fine)
- `ls pipeline/package.json pipeline/tsconfig.json pipeline/vitest.config.ts` all exist
  </verify>
  <done>
pipeline/ directory exists as a standalone pnpm project with all dependencies installed, TypeScript strict config, vitest configured, Sharp verified working, and output/ gitignored. No pnpm-workspace.yaml exists.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create shared types, path resolution config, and filesystem utilities</name>
  <files>
    pipeline/src/types/pipeline.ts
    pipeline/src/types/manga.ts
    pipeline/src/types/index.ts
    pipeline/src/config/paths.ts
    pipeline/src/config/defaults.ts
    pipeline/src/utils/fs.ts
    pipeline/tests/config/paths.test.ts
    pipeline/tests/utils/fs.test.ts
  </files>
  <action>
Create the foundation modules that all stages will import:

1. **pipeline/src/types/pipeline.ts** -- Core pipeline types:
   - `StageResult` interface: `stage: string`, `success: boolean`, `outputFiles: string[]`, `errors: string[]`, `duration: number` (milliseconds)
   - `StageOptions` interface: `chapter: number`, `verbose?: boolean`, `dryRun?: boolean`
   - `StageName` type: union of `'script' | 'prompt' | 'generate' | 'overlay' | 'assemble'`

2. **pipeline/src/types/manga.ts** -- Manga domain types (stubs for Phase 2 to flesh out):
   - `Panel` interface: `id: string`, `pageNumber: number`, `panelNumber: number`, `description: string`
   - `Page` interface: `pageNumber: number`, `panels: Panel[]`
   - `Chapter` interface: `chapterNumber: number`, `title: string`, `pages: Page[]`

3. **pipeline/src/types/index.ts** -- Re-export barrel file:
   - Re-export everything from `./pipeline.js` and `./manga.js`

4. **pipeline/src/config/paths.ts** -- Centralized path resolution:
   - Derive PROJECT_ROOT from `import.meta.url`: `path.dirname(fileURLToPath(import.meta.url))` then resolve `../../..` (from config/ -> src/ -> pipeline/ -> project root)
   - Export `PATHS` object with:
     - `bible`: `path.join(PROJECT_ROOT, '01_bible')`
     - `manga`: `path.join(PROJECT_ROOT, '03_manga')`
     - `prompts`: `path.join(PROJECT_ROOT, '03_manga', 'prompts')`
     - `output`: `path.join(PROJECT_ROOT, 'output')`
     - `chapterOutput(chapter: number)` function returning `{ root, raw, processed, lettered, webtoon }` paths under `output/ch-NN/`
   - Use exact pattern from research (Pattern 2: Centralized Path Resolution)
   - CRITICAL: Source paths (bible, manga) are READ-ONLY. Only `output` is writable.

5. **pipeline/src/config/defaults.ts** -- Default configuration values:
   - `DEFAULT_CHAPTER = 1`
   - `PIPELINE_VERSION = '0.1.0'`
   - `STAGE_NAMES` array of all 5 stage names

6. **pipeline/src/utils/fs.ts** -- File system helpers:
   - `ensureDir(dirPath: string): Promise<void>` -- creates directory recursively if it doesn't exist (using `fs.mkdir` with `recursive: true`)
   - `isReadableDir(dirPath: string): boolean` -- checks if a directory exists and is readable (using `existsSync` + `accessSync` with `constants.R_OK`)
   - `assertSourceDir(dirPath: string, name: string): void` -- throws a descriptive error if directory doesn't exist or isn't readable. Used by stages to validate source dirs before processing.

7. **pipeline/tests/config/paths.test.ts** -- Path resolution tests:
   - Test that `PATHS.bible` contains '01_bible' and `existsSync` returns true
   - Test that `PATHS.manga` contains '03_manga' and `existsSync` returns true
   - Test that `PATHS.output` parent directory equals `PATHS.bible` parent directory (output is sibling of source dirs, not inside pipeline/)
   - Test that `PATHS.chapterOutput(1)` returns paths containing 'ch-01', 'raw', 'processed', 'lettered', 'webtoon'
   - Use exact test pattern from research (Path Resolution Test)

8. **pipeline/tests/utils/fs.test.ts** -- Utility tests:
   - Test that `isReadableDir` returns true for PATHS.bible and PATHS.manga
   - Test that `isReadableDir` returns false for a nonexistent path
   - Test that `assertSourceDir` throws for a nonexistent path with a descriptive message
   - Test that `ensureDir` creates a temp directory and it exists afterward (use a temp path under `output/` and clean up after)

IMPORTANT: All imports between these files MUST use `.js` extensions (ESM requirement). Example: `import { PATHS } from '../config/paths.js'`
IMPORTANT: Use `import type` for type-only imports (verbatimModuleSyntax requires this).
  </action>
  <verify>
Run from pipeline/ directory:
- `pnpm run typecheck` exits 0 (all types are valid)
- `pnpm run test:run` passes all path resolution and utility tests
  </verify>
  <done>
Shared types (StageResult, StageOptions, Panel, Page, Chapter) exist and typecheck. PATHS resolves 01_bible/ and 03_manga/ to real directories. FS utilities provide ensureDir, isReadableDir, and assertSourceDir. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create CLI entry point with Commander subcommands and all 5 stage stubs</name>
  <files>
    pipeline/src/cli.ts
    pipeline/src/stages/script.ts
    pipeline/src/stages/prompt.ts
    pipeline/src/stages/generate.ts
    pipeline/src/stages/overlay.ts
    pipeline/src/stages/assemble.ts
    pipeline/tests/stages/script.test.ts
  </files>
  <action>
Create the CLI and stage scaffolding:

1. **pipeline/src/stages/script.ts** -- Script stage stub:
   - Export `async function runScript(options: StageOptions): Promise<StageResult>`
   - Verify PATHS.manga exists using `assertSourceDir`
   - Log `[script] Chapter ${options.chapter} -- stage not yet implemented`
   - Return StageResult with stage: 'script', success: true, empty outputFiles, empty errors
   - Use exact pattern from research (Stage Stub)

2. **pipeline/src/stages/prompt.ts** -- Prompt stage stub:
   - Same pattern as script.ts but stage name is 'prompt'
   - Verify PATHS.manga exists (prompts come from manga scripts)

3. **pipeline/src/stages/generate.ts** -- Generate stage stub:
   - Same pattern, stage name 'generate'
   - Verify PATHS.output parent exists (will write to output/)

4. **pipeline/src/stages/overlay.ts** -- Overlay stage stub:
   - Same pattern, stage name 'overlay'
   - Verify PATHS.output parent exists

5. **pipeline/src/stages/assemble.ts** -- Assemble stage stub:
   - Same pattern, stage name 'assemble'
   - Verify PATHS.output parent exists

6. **pipeline/src/cli.ts** -- Commander CLI entry point:
   - Import Command from 'commander'
   - Create program with name 'plasma-pipeline', description 'Manga production pipeline for Plasma', version '0.1.0'
   - Register 5 subcommands: `script`, `prompt`, `generate`, `overlay`, `assemble`
   - Each subcommand has: `.requiredOption('-c, --chapter <number>', 'Chapter number')`, `.option('-v, --verbose', 'Enable verbose logging')`, `.option('--dry-run', 'Show what would be done without doing it')`
   - Each subcommand's action handler: dynamically imports the stage module, parses chapter as integer, calls the stage function, logs result, exits 1 on failure
   - Use exact CLI pattern from research (Pattern 1: Subcommand-Per-Stage CLI)
   - CRITICAL: Dynamic imports use `.js` extensions: `await import('./stages/script.js')`

7. **pipeline/tests/stages/script.test.ts** -- Stage contract test:
   - Test that `runScript({ chapter: 1 })` returns a StageResult with correct shape (has stage, success, outputFiles, errors, duration fields)
   - Test that `runScript({ chapter: 1 })` returns success: true (stub always succeeds)
   - Test that `runScript({ chapter: 1 })` returns stage: 'script'
   - Test that duration is a positive number

After creating all files, run the full verification sequence:
- `pnpm run typecheck` to confirm all types are valid
- `pnpm run test:run` to confirm all tests pass
- `pnpm tsx src/cli.ts --help` to confirm CLI prints help with all 5 subcommands
- `pnpm tsx src/cli.ts script -c 1` to confirm a stage runs and exits cleanly
- `pnpm tsx src/cli.ts assemble -c 1` to confirm another stage works too
  </action>
  <verify>
Run from pipeline/ directory:
- `pnpm run typecheck` exits 0
- `pnpm run test:run` passes all tests (paths, utils, stages)
- `pnpm tsx src/cli.ts --help` shows all 5 subcommands
- `pnpm tsx src/cli.ts script -c 1` exits 0 with stub message
- `pnpm tsx src/cli.ts prompt -c 1` exits 0 with stub message
- `pnpm tsx src/cli.ts generate -c 1` exits 0 with stub message
- `pnpm tsx src/cli.ts overlay -c 1` exits 0 with stub message
- `pnpm tsx src/cli.ts assemble -c 1` exits 0 with stub message
  </verify>
  <done>
CLI entry point works with all 5 stage subcommands. Each stage accepts --chapter, --verbose, and --dry-run options. Each stage stub verifies source directories exist, prints a stub message, and returns a well-typed StageResult. All tests pass. The pipeline infrastructure is complete and ready for Phase 2 to implement real stage logic.
  </done>
</task>

</tasks>

<verification>
Phase 1 is complete when all of the following are true:

1. **INFR-01**: `pipeline/` exists as a standalone TypeScript project with its own `package.json`, completely decoupled from story content directories
2. **INFR-02**: TypeScript strict mode is enabled in `tsconfig.json`, Sharp is installed and verified working, vitest is configured
3. **INFR-03**: `PATHS` config resolves `01_bible/` and `03_manga/` as read-only sources. `output/` is the only write target. Tests prove source paths resolve to real directories
4. **INFR-04**: `pnpm tsx src/cli.ts <stage> -c 1` works for all 5 stages (script, prompt, generate, overlay, assemble). `pnpm run stage:script` etc. also work
5. **INFR-05**: All work is on a feature branch (current branch: `feature/draster-and-june-wip-concept` or create `feature/pipeline-setup`)

Run the full verification:
```bash
cd pipeline
pnpm run typecheck        # TypeScript compiles clean
pnpm run test:run         # All tests pass
pnpm tsx src/cli.ts --help         # Shows 5 subcommands
pnpm tsx src/cli.ts script -c 1    # Exits 0
pnpm tsx src/cli.ts assemble -c 1  # Exits 0
git branch --show-current          # Shows feature branch, not main
```
</verification>

<success_criteria>
- pipeline/package.json exists with pnpm, ESM ("type": "module"), all dependencies
- pipeline/tsconfig.json has strict: true, NodeNext module resolution
- Sharp imports successfully and prints version info
- `pnpm tsx src/cli.ts --help` lists script, prompt, generate, overlay, assemble subcommands
- `pnpm tsx src/cli.ts script -c 1` runs and exits 0
- `pnpm run test:run` passes with 0 failures (path resolution, utility, stage contract tests)
- output/ is in .gitignore
- No files written to 01_bible/ or 03_manga/
- All work on a feature branch
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
