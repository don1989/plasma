---
phase: 02-scripts-characters-and-prompts
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - pipeline/src/parsers/script-parser.ts
  - pipeline/src/stages/script.ts
  - pipeline/tests/parsers/script-parser.test.ts
  - pipeline/tests/stages/script.test.ts
autonomous: true
requirements: [SCRP-01, SCRP-02, SCRP-03]

must_haves:
  truths:
    - "Running the script stage for chapter 1 parses chapter-01-script.md into a typed Chapter object"
    - "Every panel has shotType, action, dialogue, sfx, notes extracted from the markdown"
    - "Splash pages and double spreads are correctly flagged"
    - "Dialogue lines distinguish speech, thought, and narration types"
    - "Script validation reports panel count warnings and missing shot types"
    - "The script stage writes a validated JSON file to output/ch-01/script.json"
  artifacts:
    - path: "pipeline/src/parsers/script-parser.ts"
      provides: "Markdown-to-Chapter parser using remark/unified"
      exports: ["parseChapterScript"]
    - path: "pipeline/src/stages/script.ts"
      provides: "Implemented script stage that reads markdown and outputs validated JSON"
      contains: "parseChapterScript"
    - path: "pipeline/tests/parsers/script-parser.test.ts"
      provides: "Parser tests covering all panel types and edge cases"
      min_lines: 80
  key_links:
    - from: "pipeline/src/parsers/script-parser.ts"
      to: "pipeline/src/schemas/manga.schema.ts"
      via: "validates parsed output with ChapterSchema"
      pattern: "ChapterSchema"
    - from: "pipeline/src/stages/script.ts"
      to: "pipeline/src/parsers/script-parser.ts"
      via: "imports parseChapterScript"
      pattern: "import.*parseChapterScript"
    - from: "pipeline/src/parsers/script-parser.ts"
      to: "03_manga/chapter-01-script.md"
      via: "reads and parses the actual manga script file"
      pattern: "readFile|readFileSync"
---

<objective>
Build the markdown script parser that converts chapter-01-script.md into a typed, validated Chapter object, and wire it into the existing script stage.

Purpose: This is the entry point of the data pipeline. Every downstream operation (prompt generation, QC checks) depends on having structured panel/page/chapter data parsed from the existing manga scripts. The parser must handle all edge cases in chapter-01-script.md: splash pages, double spreads, em-dash dialogue, thought bubbles, silent panels, off-panel speech, tags like [PAGE-TURN REVEAL], and the Director's Notes footer sections.

Output: Working script parser that reads 03_manga/chapter-01-script.md and produces output/ch-01/script.json with all 29 pages parsed and validated.
</objective>

<execution_context>
@/Users/dondemetrius/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dondemetrius/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-scripts-characters-and-prompts/02-01-SUMMARY.md
@pipeline/src/types/manga.ts
@pipeline/src/schemas/manga.schema.ts
@pipeline/src/stages/script.ts
@pipeline/src/config/paths.ts
@03_manga/chapter-01-script.md
@03_manga/manga-script.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement the markdown script parser</name>
  <files>
    pipeline/src/parsers/script-parser.ts
    pipeline/tests/parsers/script-parser.test.ts
  </files>
  <action>
Create pipeline/src/parsers/script-parser.ts with a `parseChapterScript(markdown: string): Chapter` function using unified + remark-parse + unist-util-visit.

**Parsing strategy (walk the MDAST tree):**

1. **H1 heading** (`# Chapter N: Title`) — extract chapterNumber and title
2. **Metadata block** (paragraphs between H1 and first H2) — extract themeBeat, estimatedPages, characters, locations from bold-labeled lines (`**Theme beat:**`, `**Estimated pages:**`, `**Characters appearing:**`, `**Locations:**`)
3. **H2 heading** (`## Page N` or `## Page N — SPLASH PAGE` or `## Page N — DOUBLE-PAGE SPREAD (Pages N-M)`) — start a new page, detect isSplash/isDoubleSpread from the heading text. Also detect `[PAGE-TURN REVEAL]` tag from heading text.
4. **H3 heading** (`### Panel N — Shot Type` or `### Panel N — Shot Type (variant)`) — start a new panel, extract panelNumber and shotType. The shot type is everything after the em-dash (` — ` using the Unicode em-dash character, NOT a regular hyphen).
5. **Bold-labeled paragraphs within a panel:**
   - `**Action:**` — everything after the label is the action text
   - `**Dialogue:**` — if the value is `—` (em-dash), set dialogue to empty array. Otherwise, parse each line:
     - `- CHARACTER: "line"` = speech
     - `- CHARACTER (thought): *line*` = thought (italicized text)
     - `- CHARACTER (off-panel): "line"` = speech (note: off-panel is a position, not a type)
     - `- (narration): *line*` = narration
   - `**SFX:**` — if `—`, set to empty string. Otherwise, capture the text.
   - `**Notes:**` — capture the text.
6. **Tags** — `[PAGE-TURN REVEAL]` and `[PLAYER DECISION POINT]` can appear in H2 headings or in blockquotes after panels. Collect into the page's or panel's tags array.
7. **Stop parsing at `## End Hook` or `## Director's Notes`** — these are footer sections, not page data. Optionally store as chapter-level metadata.

**Critical edge cases from chapter-01-script.md:**
- Em-dash `—` (Unicode U+2014) is used everywhere, NOT regular hyphens. The heading separator between Panel N and Shot Type is ` — `. The "no dialogue" marker is `—`.
- Page 23 is `## Page 23 — SPLASH PAGE` with a single `### Panel 1 — Full Page`
- Page 25 is `## Page 25 — DOUBLE-PAGE SPREAD (Pages 25-26)` with `### Panel 1 — Full Double Spread`
- Page 22 has `[PAGE-TURN REVEAL]` in the H2 heading
- Page 24 Panel 1 has shot type `Black` (a black panel)
- Page 29 has a blockquote `> **[PLAYER DECISION POINT]**` after the last panel
- Dialogue lines use `*italics*` for thought bubbles
- Some panels have multi-sentence action text spanning multiple lines (remark will join these in a single paragraph node)
- The `**Canon references:**` metadata line in the header is a long paragraph — parse it but don't break on its length

**extractText helper:** Create a helper function that recursively extracts plain text from any MDAST node (handles nested Strong, Emphasis, Text, InlineCode nodes). This is needed because bold labels like `**Action:**` are Strong nodes wrapping Text nodes.

Export `parseChapterScript` and also export a `validateChapter` function that runs the parsed Chapter through the ChapterSchema from manga.schema.ts and returns `{ valid: boolean, errors: ZodError[], warnings: string[] }`. Warnings are for non-blocking issues (e.g., standard page with 3 panels — unusual but not invalid).

Create pipeline/tests/parsers/script-parser.test.ts with:
- Parse a minimal valid script (1 page, 1 panel) — returns Chapter with correct structure
- Parse a page with 4 panels — all panels have shotType, action, dialogue, sfx, notes
- Parse dialogue with speech, thought, and narration types correctly
- Parse silent panel (dialogue: —) — dialogue array is empty
- Parse splash page — isSplash is true, 1 panel
- Parse double spread — isDoubleSpread is true
- Parse header metadata — themeBeat, characters, locations extracted
- Parse chapter-01-script.md (the real file) — returns 29 pages, chapter number 1, title "The Exam"
- Validate a well-formed chapter — valid is true
- Validate a chapter with no Wide shots — returns error
  </action>
  <verify>
Run `cd /Users/dondemetrius/Code/plasma/pipeline && pnpm run test:run -- tests/parsers/` — all parser tests pass. Run `pnpm run typecheck` — no type errors.
  </verify>
  <done>parseChapterScript correctly parses chapter-01-script.md into 29 pages with all panel fields populated. Splash page (p23) and double spread (p25) correctly flagged. Dialogue types (speech/thought/narration) correctly distinguished. 10+ tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Wire parser into script stage with JSON output</name>
  <files>
    pipeline/src/stages/script.ts
    pipeline/tests/stages/script.test.ts
  </files>
  <action>
Replace the stub implementation in pipeline/src/stages/script.ts with real logic:

1. Read the manga script file: `path.join(PATHS.manga, `chapter-${chapterNum}-script.md`)` where chapterNum is zero-padded (e.g., `chapter-01-script.md`)
2. Call `parseChapterScript(markdownContent)` to get the Chapter object
3. Call `validateChapter(chapter)` to validate. Log warnings. If validation has errors, return `{ success: false, errors: [...] }`
4. Write the validated Chapter as formatted JSON to `output/ch-NN/script.json` (using PATHS.chapterOutput and ensureDir)
5. Return StageResult with outputFiles listing the JSON path

Handle the case where the script file doesn't exist: return `{ success: false, errors: ['Script file not found: ...'] }` with a clear path in the error message.

If `options.verbose` is true, log the parse summary: number of pages, total panels, character count, validation warnings.

If `options.dryRun` is true, parse and validate but skip writing the JSON file.

Update pipeline/tests/stages/script.test.ts (expand the existing stub tests):
- Script stage reads chapter-01-script.md and produces output (integration test using the real file)
- Script stage returns correct outputFiles path
- Script stage returns error for non-existent chapter
- Script stage with dryRun does not write file
  </action>
  <verify>
Run `cd /Users/dondemetrius/Code/plasma/pipeline && pnpm run test:run -- tests/stages/script.test.ts` — all tests pass. Run `pnpm run stage:script -- -c 1 --verbose` from pipeline/ — should parse chapter-01-script.md and write output/ch-01/script.json. Inspect the JSON to verify 29 pages are present.
  </verify>
  <done>Running `pnpm run stage:script -- -c 1` produces output/ch-01/script.json with all 29 pages, correctly typed panels, and validation passes. Stage returns StageResult with outputFiles listing the JSON path. Tests pass including the integration test against the real chapter-01-script.md.</done>
</task>

</tasks>

<verification>
- `cd pipeline && pnpm run typecheck` exits 0
- `cd pipeline && pnpm run test:run` — all tests pass (previous + new parser + stage tests)
- `pnpm run stage:script -- -c 1` writes output/ch-01/script.json
- output/ch-01/script.json contains 29 pages with panelNumber, shotType, action, dialogue, sfx, notes for each panel
- Page 23 has isSplash: true
- Page 25 has isDoubleSpread: true
- Dialogue lines have correct type (speech/thought/narration)
</verification>

<success_criteria>
The script stage converts chapter-01-script.md into a fully structured, validated JSON file. All 29 pages parsed with correct panel data. Splash/spread pages correctly identified. Dialogue types correctly parsed. Validation reports any rule violations.
</success_criteria>

<output>
After completion, create `.planning/phases/02-scripts-characters-and-prompts/02-02-SUMMARY.md`
</output>
