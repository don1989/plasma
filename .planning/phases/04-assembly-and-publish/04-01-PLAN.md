---
phase: 04-assembly-and-publish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pipeline/src/types/overlay.ts
  - pipeline/src/overlay/balloon.ts
  - pipeline/src/overlay/text-measure.ts
  - pipeline/src/overlay/sfx.ts
  - pipeline/src/overlay/renderer.ts
  - pipeline/src/stages/overlay.ts
  - pipeline/src/cli.ts
autonomous: true
requirements:
  - TEXT-01
  - TEXT-02
  - ASSM-04

must_haves:
  truths:
    - "Running `overlay -c 1` reads approved panel images from raw/ and script.json dialogue, producing lettered PNG images in lettered/"
    - "Speech balloons render as white ellipses with black stroke, containing readable text, composited onto the panel image"
    - "Thought bubbles render with dashed stroke, narration boxes render as rectangles — distinct from speech balloons"
    - "SFX text renders as large colored text without a balloon shape"
    - "Balloon sizes auto-scale to fit dialogue text content with padding"
    - "Overlay stage never writes to raw/ — reads from raw/, writes only to lettered/"
  artifacts:
    - path: "pipeline/src/types/overlay.ts"
      provides: "Overlay-specific types (BalloonConfig, OverlayConfig, SfxConfig, PageOverlayData)"
      min_lines: 30
    - path: "pipeline/src/overlay/balloon.ts"
      provides: "SVG speech balloon generator for speech, thought, and narration types"
      exports: ["generateBalloonSvg"]
    - path: "pipeline/src/overlay/text-measure.ts"
      provides: "Text measurement via Sharp Pango for auto-sizing balloons"
      exports: ["measureText"]
    - path: "pipeline/src/overlay/sfx.ts"
      provides: "SFX text rendering via Sharp Pango markup"
      exports: ["renderSfx"]
    - path: "pipeline/src/overlay/renderer.ts"
      provides: "Orchestrator compositing balloons and SFX onto panel images"
      exports: ["overlayPage"]
    - path: "pipeline/src/stages/overlay.ts"
      provides: "Stage entry point reading script.json + manifest + raw/ images"
      exports: ["runOverlay"]
  key_links:
    - from: "pipeline/src/overlay/renderer.ts"
      to: "output/ch-NN/script.json"
      via: "Reads dialogue lines per page from parsed script"
      pattern: "readFile.*script\\.json"
    - from: "pipeline/src/overlay/renderer.ts"
      to: "output/ch-NN/raw/"
      via: "Reads approved panel images from generation manifest"
      pattern: "getApprovedEntry|raw/"
    - from: "pipeline/src/overlay/balloon.ts"
      to: "sharp composite"
      via: "SVG Buffer passed to sharp().composite()"
      pattern: "composite.*input.*generateBalloonSvg"
    - from: "pipeline/src/stages/overlay.ts"
      to: "output/ch-NN/lettered/"
      via: "Writes lettered PNG files to lettered/ directory"
      pattern: "lettered.*toFile|writeFile"
---

<objective>
Build the dialogue overlay stage that composites speech balloons, thought bubbles, narration boxes, and SFX text onto approved panel images, producing lettered PNG files.

Purpose: This is the first half of Phase 4 — converting raw AI-generated panel images into lettered pages with readable dialogue. Text is never baked into Gemini prompts (Gemini garbles text), so all dialogue must be added programmatically after image generation.

Output: Overlay module (`pipeline/src/overlay/`) with balloon SVG generator, text measurement, SFX renderer, and page compositor. Updated overlay stage and CLI with page-range support.
</objective>

<execution_context>
@/Users/dondemetrius/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dondemetrius/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-assembly-and-publish/04-RESEARCH.md

@pipeline/src/types/manga.ts
@pipeline/src/types/generation.ts
@pipeline/src/types/pipeline.ts
@pipeline/src/config/paths.ts
@pipeline/src/generation/manifest.ts
@pipeline/src/stages/overlay.ts
@pipeline/src/cli.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create overlay types, SVG balloon generator, and text measurement</name>
  <files>
    pipeline/src/types/overlay.ts
    pipeline/src/overlay/balloon.ts
    pipeline/src/overlay/text-measure.ts
    pipeline/src/overlay/sfx.ts
  </files>
  <action>
Create the overlay type definitions and three core modules:

**1. `pipeline/src/types/overlay.ts`** — Overlay-specific types:
- `BalloonType`: `'speech' | 'thought' | 'narration'` (maps from DialogueLine.type)
- `BalloonConfig`: `{ text: string; type: BalloonType; x: number; y: number; maxWidth?: number }`
- `SfxConfig`: `{ text: string; x: number; y: number; fontSize?: number; color?: string }`
- `PageOverlayData`: `{ pageNumber: number; panelCount: number; dialogueLines: DialogueLine[]; sfx: string; isSplash: boolean; isDoubleSpread: boolean }`
- `OverlayConfig`: `{ font: string; fontSize: number; dpi: number; balloonPadding: { x: number; y: number }; maxBalloonWidth: number; sfxFont: string; sfxFontSize: number; sfxColor: string }`
- Export a `DEFAULT_OVERLAY_CONFIG` constant with sensible defaults: font `'sans-serif'`, fontSize `14`, dpi `150`, balloonPadding `{ x: 20, y: 15 }`, maxBalloonWidth `280`, sfxFont `'Impact'`, sfxFontSize `22`, sfxColor `'#CC0000'`

**2. `pipeline/src/overlay/balloon.ts`** — SVG speech balloon generator:
- Export `generateBalloonSvg(text: string, width: number, height: number, type: BalloonType): Buffer`
- Speech type: white-filled ellipse with black 2.5px stroke, triangular tail pointer at bottom center pointing down
- Thought type: white-filled ellipse with black 2px dashed stroke (`stroke-dasharray="8,4"`), no tail (thought bubbles use small circles, but for v1 just use dashed ellipse)
- Narration type: beige-filled (`#f5f5dc`) rectangle with 4px corner radius, black 2px stroke
- All types: center text using SVG `<text>` with `text-anchor="middle"` and `dominant-baseline="middle"`
- Escape XML entities in text (& < > " ')
- SVG viewport sized to `width x (height + tailHeight)` where `tailHeight` is 30 for speech, 0 for others
- Return `Buffer.from(svgString)` for Sharp composite input

**3. `pipeline/src/overlay/text-measure.ts`** — Text measurement:
- Export `measureText(text: string, font: string, fontSize: number, maxWidth: number, dpi?: number): Promise<{ width: number; height: number }>`
- Uses `sharp({ text: { text: pangoMarkup, dpi, rgba: true, width: maxWidth, wrap: 'word' } }).png().toBuffer()` then reads metadata for dimensions
- The Pango markup wraps text in `<span font="FONT SIZE">` tags
- Export `calculateBalloonSize(text: string, config: OverlayConfig): Promise<{ width: number; height: number }>` which calls `measureText` then adds padding: `width + 2*padding.x`, `height + 2*padding.y`, clamped to `maxBalloonWidth`

**4. `pipeline/src/overlay/sfx.ts`** — SFX text rendering:
- Export `renderSfx(text: string, config: OverlayConfig): Promise<Buffer>`
- Uses `sharp({ text: { text: pangoMarkup, font: config.sfxFont, dpi: config.dpi, rgba: true } }).png().toBuffer()`
- Pango markup: `<span font="SFXFONT SFXFONTSIZE" foreground="SFXCOLOR" letter_spacing="2048">TEXT</span>`
- Skip rendering if text is empty or just a dash (`'—'`)

Use ESM imports with `.js` extensions throughout. Use `import type` for type-only imports per project convention.
  </action>
  <verify>
Run `cd /Users/dondemetrius/Code/plasma/pipeline && npx tsc --noEmit` — no type errors.
Verify all 4 files exist and export the expected symbols.
  </verify>
  <done>
Four overlay modules exist with typed interfaces. BalloonSvg generates valid SVG strings for 3 balloon types. Text measurement uses Sharp Pango. SFX renders colored Pango text. All pass type checking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build overlay renderer and wire overlay stage with CLI support</name>
  <files>
    pipeline/src/overlay/renderer.ts
    pipeline/src/stages/overlay.ts
    pipeline/src/cli.ts
  </files>
  <action>
Build the page overlay renderer and connect it to the existing stage stub and CLI:

**1. `pipeline/src/overlay/renderer.ts`** — Page compositor:
- Export `overlayPage(imagePath: string, overlayData: PageOverlayData, config?: OverlayConfig): Promise<Buffer>`
- For each `dialogueLine` in `overlayData.dialogueLines`:
  1. Call `calculateBalloonSize(line.line, config)` to get auto-sized balloon dimensions
  2. Call `generateBalloonSvg(line.line, balloonWidth, balloonHeight, line.type as BalloonType)` to create SVG buffer
  3. Calculate placement using heuristic: divide image height into zones by `panelCount`, place balloons within the top portion of each zone. First dialogue line at top-left, subsequent lines offset rightward and downward. Use `sharp(imagePath).metadata()` for image dimensions.
  4. Add to composites array: `{ input: svgBuffer, top: yPos, left: xPos }`
- For SFX (if present and not `'—'`): call `renderSfx(overlayData.sfx, config)`, place with gravity `'south'` or explicit bottom-center position
- Composite all overlays in one `sharp(imagePath).composite(composites).png().toBuffer()` call
- Return the composited PNG buffer

**2. `pipeline/src/stages/overlay.ts`** — Replace the stub:
- Read `script.json` from `PATHS.chapterOutput(chapter).root` via `readFile` + `JSON.parse` and cast to `Chapter` type
- Read `generation-log.json` via `loadManifest(chapterRoot, chapter)` to find approved images
- For each page in `chapter.pages`:
  1. Find approved image via `getApprovedEntry(manifest, page.pageNumber)` — if none, log warning and skip page
  2. Build `PageOverlayData` from the page (flatten all panels' dialogue lines, combine SFX, include isSplash/isDoubleSpread, panel count)
  3. If no dialogue and no SFX, copy raw image directly to lettered/ (passthrough — still need the image for assembly)
  4. Otherwise call `overlayPage(rawImagePath, overlayData)` to get lettered buffer
  5. Write lettered buffer as PNG to `PATHS.chapterOutput(chapter).lettered/` with same base filename as raw image
- Use `ensureDir` to create `lettered/` directory
- Return `StageResult` with success status, list of output files, any errors/warnings
- Support `--dry-run` (log what would be done, don't write) and `--verbose` (log each page processed)

**3. `pipeline/src/cli.ts`** — Expand overlay subcommand:
- Add `--page <number>` option to overlay a single page
- Add `--pages <range>` option for page ranges (reuse same parsing logic as generate command: `"1-5"` ranges and `"3,7,12"` comma-separated)
- Pass `page`/`pages` to `runOverlay` via extended options (add optional `page?: number` and `pages?: number[]` to `StageOptions` or pass as separate generate-style options object)

Follow existing stage patterns: read file -> process -> validate -> write, with verbose/dryRun/error handling. Keep ESM `.js` import extensions.
  </action>
  <verify>
Run `cd /Users/dondemetrius/Code/plasma/pipeline && npx tsc --noEmit` — no type errors.
Run `cd /Users/dondemetrius/Code/plasma/pipeline && npx tsx src/cli.ts overlay -c 1 --dry-run` — should execute without crashes (will log skips for missing approved images).
Verify `pipeline/src/overlay/renderer.ts` imports from `balloon.js`, `text-measure.js`, `sfx.js`.
Verify `pipeline/src/stages/overlay.ts` imports from `../overlay/renderer.js` and `../generation/manifest.js`.
  </verify>
  <done>
Overlay stage reads script.json + generation manifest, composites speech balloons and SFX onto approved raw images, writes lettered PNGs to lettered/ directory. CLI supports --page and --pages for selective overlay. Dry-run mode works without approved images.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npx tsx src/cli.ts overlay -c 1 --dry-run` runs without crashes
3. Overlay types, balloon generator, text measurement, SFX renderer, page renderer, stage, and CLI are all wired
4. No file writes to `raw/` — overlay reads from `raw/`, writes to `lettered/`
5. Generated SVG balloons are valid (speech = ellipse + tail, thought = dashed ellipse, narration = rectangle)
</verification>

<success_criteria>
The overlay stage is fully functional: given approved raw panel images and a script.json, it produces lettered PNG images with speech balloons, thought bubbles, narration boxes, and SFX text overlaid. Intermediate lettered/ artifacts are preserved separately from raw/ images.
</success_criteria>

<output>
After completion, create `.planning/phases/04-assembly-and-publish/04-01-SUMMARY.md`
</output>
