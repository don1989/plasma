---
phase: 03-image-generation-workflow
plan: 02
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - pipeline/src/generation/image-import.ts
  - pipeline/src/stages/generate.ts
  - pipeline/src/cli.ts
  - pipeline/tests/generation/image-import.test.ts
  - pipeline/tests/stages/generate.test.ts
autonomous: true
requirements:
  - IGEN-01
  - IGEN-03
  - IGEN-04

must_haves:
  truths:
    - "User can run `generate --manual -c 1` and see all 28 page prompts displayed for copy-paste"
    - "User can import a downloaded image with `generate --manual -c 1 --import ~/Downloads/image.png --page 3` and it lands in output/ch-01/raw/ with correct naming"
    - "Imported image is recorded in generation-log.json with model='manual', prompt hash, and timestamp"
    - "Version auto-increments -- importing a second image for the same page produces v2, not overwriting v1"
    - "User can approve an image with `generate --approve ch01_p003_v1.png -c 1`"
  artifacts:
    - path: "pipeline/src/generation/image-import.ts"
      provides: "importImage function for manual workflow"
      exports: ["importImage"]
    - path: "pipeline/src/stages/generate.ts"
      provides: "Dual-mode generate stage with manual workflow fully functional"
      exports: ["runGenerate", "GenerateOptions"]
    - path: "pipeline/src/cli.ts"
      provides: "Expanded generate subcommand with --manual, --import, --page, --approve flags"
    - path: "pipeline/tests/generation/image-import.test.ts"
      provides: "Image import tests"
      min_lines: 30
  key_links:
    - from: "pipeline/src/generation/image-import.ts"
      to: "pipeline/src/generation/naming.ts"
      via: "panelImageFilename and nextVersion imports"
      pattern: "import.*panelImageFilename.*naming"
    - from: "pipeline/src/generation/image-import.ts"
      to: "pipeline/src/generation/manifest.ts"
      via: "hashPrompt and manifest operations"
      pattern: "import.*hashPrompt.*manifest"
    - from: "pipeline/src/stages/generate.ts"
      to: "pipeline/src/generation/image-import.ts"
      via: "importImage call in manual mode"
      pattern: "import.*importImage"
    - from: "pipeline/src/stages/generate.ts"
      to: "pipeline/src/generation/manifest.ts"
      via: "loadManifest, addEntry, saveManifest"
      pattern: "import.*(loadManifest|addEntry)"
    - from: "pipeline/src/cli.ts"
      to: "pipeline/src/stages/generate.ts"
      via: "dynamic import in generate command action"
      pattern: "import.*stages/generate"
---

<objective>
Implement the manual Gemini workflow end-to-end: display prompts for copy-paste, import downloaded images with correct naming and versioning, record every import in the generation manifest, and support image approval.

Purpose: The manual workflow (IGEN-01) is the first-class path that works regardless of API access. This plan delivers immediate value -- the user can generate images via the Gemini web UI and have them organized, named, and tracked by the pipeline.

Output: Working `generate --manual` CLI command with import and approval capabilities. Full prompt-to-image traceability via generation-log.json.
</objective>

<execution_context>
@/Users/dondemetrius/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dondemetrius/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-image-generation-workflow/03-01-SUMMARY.md

@pipeline/src/stages/generate.ts
@pipeline/src/cli.ts
@pipeline/src/types/pipeline.ts
@pipeline/src/types/generation.ts
@pipeline/src/generation/naming.ts
@pipeline/src/generation/manifest.ts
@pipeline/src/config/paths.ts
@pipeline/src/config/defaults.ts
@pipeline/src/utils/fs.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Image import module and generate stage with manual workflow</name>
  <files>
    pipeline/src/generation/image-import.ts
    pipeline/src/stages/generate.ts
    pipeline/tests/generation/image-import.test.ts
    pipeline/tests/stages/generate.test.ts
  </files>
  <action>
**Create `pipeline/src/generation/image-import.ts`:**

Export `importImage(opts)` function:
```
opts: {
  sourcePath: string;   // Path to downloaded image (e.g., ~/Downloads/image.png)
  chapter: number;
  page: number;
  rawDir: string;       // output/ch-NN/raw/
  promptsDir: string;   // output/ch-NN/prompts/
  chapterDir: string;   // output/ch-NN/
  notes?: string;       // Optional notes about this generation
}
returns: Promise<{ destPath: string; entry: GenerationLogEntry }>
```

Implementation steps:
1. Validate source file exists (`existsSync`). Throw descriptive error if not.
2. Validate source is a readable image using `sharp(sourcePath).metadata()` -- check format is png/jpeg/webp. Log dimensions if verbose.
3. Call `ensureDir(rawDir)` to create raw/ if needed.
4. Call `nextVersion(rawDir, chapter, page)` to get the next version number.
5. Call `panelImageFilename(chapter, page, version)` to build the destination filename. Use the source file extension (not hardcoded png) -- if jpeg, use jpg for consistency.
6. Copy (not move) the source file to `path.join(rawDir, filename)` using `copyFile` from `node:fs/promises`. Never delete the user's original.
7. Read the corresponding prompt file: `path.join(promptsDir, `page-${String(page).padStart(2, '0')}.txt`)`. If prompt file doesn't exist, use empty string and log a warning.
8. Hash the prompt text using `hashPrompt()`.
9. Build a `GenerationLogEntry` with: `imageFile: filename`, `promptFile: relative path from chapterDir`, `promptHash`, `model: 'manual'`, `timestamp: new Date().toISOString()`, `version`, `approved: false`, `notes` (if provided), `promptText` (full text for traceability).
10. Return `{ destPath, entry }`.

Export `approveImage(opts)` function:
```
opts: {
  imageFile: string;    // e.g., "ch01_p003_v1.png"
  chapterDir: string;
}
returns: Promise<void>
```

Implementation: Load manifest, find entry by imageFile, set `approved: true`, unapprove any other versions of the same page (only one approved per page), save manifest.

**Rewrite `pipeline/src/stages/generate.ts`:**

Define `GenerateOptions` extending `StageOptions`:
```typescript
export interface GenerateOptions extends StageOptions {
  mode: 'manual' | 'api';
  importPath?: string;    // --import <path>
  page?: number;          // --page <number>
  pages?: number[];       // --pages <range> parsed to array
  model?: string;
  approve?: string;       // --approve <filename>
  notes?: string;
}
```

Implement `runGenerate(options: GenerateOptions): Promise<StageResult>`:

1. Resolve chapter paths via `PATHS.chapterOutput(options.chapter)`.
2. If `options.approve` is set: call `approveImage`, log success, return early.
3. If `options.mode === 'manual'`:
   a. If `options.importPath` and `options.page`: handle single image import:
      - Call `importImage(...)` with the resolved paths
      - Load manifest, call `addEntry` with the returned entry
      - Log: `[generate] Imported: ch01_p003_v1.png -> output/ch-01/raw/`
      - Return StageResult with the output file path
   b. Else: display prompts for copy-paste:
      - Read all .txt files from prompts/ dir, sorted naturally
      - For each prompt file, display with clear separators:
        ```
        ============================================================
        PAGE 3 -- Copy the prompt below into Gemini:
        ============================================================
        [prompt text]
        ============================================================
        After generating, import with:
          pnpm stage:generate -- --manual -c 1 --import <downloaded-image-path> --page 3
        ```
      - If `options.pages` is set, filter to only those pages
      - Return StageResult with 0 output files (display only)
4. If `options.mode === 'api'`: log `[generate] API mode not yet implemented. Use --manual for now.` and return success with empty outputs. (API mode implemented in Plan 03.)

**Create `pipeline/tests/generation/image-import.test.ts`:**

Test cases for importImage:
1. Copies file to raw/ with correct naming convention
2. Does not delete the source file (copy, not move)
3. Returns a GenerationLogEntry with model='manual'
4. Reads and hashes the corresponding prompt file
5. Auto-increments version when file already exists in raw/
6. Throws on non-existent source file
7. Creates raw/ directory if it doesn't exist
8. Handles missing prompt file gracefully (empty hash, warning)

Test cases for approveImage:
9. Sets approved=true on the specified entry
10. Unapproves other versions of the same page

Use temp directories with pre-created test images (use sharp to create a 10x10 PNG in beforeEach for a real image file that passes metadata validation). Create test prompt files matching the expected naming.

**Create `pipeline/tests/stages/generate.test.ts`:**

Test the generate stage orchestration:
1. Manual mode with --import calls importImage and updates manifest
2. Manual mode without --import reads and displays prompt files (capture console.log)
3. Approve mode finds and marks entry as approved
4. API mode returns not-yet-implemented message (for now)

Use mocking sparingly -- prefer real file system operations with temp dirs.
  </action>
  <verify>
    `cd /Users/dondemetrius/Code/plasma/pipeline && pnpm test:run -- tests/generation/image-import.test.ts` -- all tests pass.
    `cd /Users/dondemetrius/Code/plasma/pipeline && pnpm test:run -- tests/stages/generate.test.ts` -- all tests pass.
    `cd /Users/dondemetrius/Code/plasma/pipeline && pnpm test:run` -- all tests pass (existing + new).
    `cd /Users/dondemetrius/Code/plasma/pipeline && pnpm typecheck` -- no type errors.
  </verify>
  <done>
    importImage copies files with correct naming, records entries, auto-increments versions. approveImage toggles approval. Generate stage orchestrates manual workflow. Tests green.
  </done>
</task>

<task type="auto">
  <name>Task 2: Expand CLI generate subcommand with manual workflow flags</name>
  <files>
    pipeline/src/cli.ts
  </files>
  <action>
**Update the existing `generate` subcommand in `pipeline/src/cli.ts`:**

Replace the current basic generate command with an expanded version:

```typescript
program
  .command('generate')
  .description('Generate panel images using Gemini AI')
  .requiredOption('-c, --chapter <number>', 'Chapter number')
  .option('--manual', 'Manual workflow: display prompts for copy-paste')
  .option('--api', 'Automated workflow: call Gemini API directly')
  .option('--import <path>', 'Import a downloaded image (use with --page)')
  .option('--page <number>', 'Page number (used with --import)')
  .option('--pages <range>', 'Page range to display/generate (e.g., "1-5" or "3,7,12")')
  .option('--model <name>', 'Gemini model override')
  .option('--approve <file>', 'Mark an image version as approved (e.g., ch01_p003_v1.png)')
  .option('--notes <text>', 'Notes for this generation (stored in manifest)')
  .option('-v, --verbose', 'Enable verbose logging')
  .option('--dry-run', 'Show what would be done without doing it')
  .action(async (options) => {
    // ... see below
  });
```

In the action handler:
1. Parse `--pages` range: support "1-5" (range) and "3,7,12" (comma-separated). Convert to `number[]`.
2. Determine mode: if `--api` is set, mode='api'. Otherwise default to mode='manual'. If neither `--manual` nor `--api`, default to 'manual' (manual is the first-class path).
3. Validate: if `--import` is set, `--page` must also be set. Print error and exit(1) if not.
4. Validate: if `--import` is set, validate the file path exists before calling the stage. Print error and exit(1) if not found.
5. Call `runGenerate` with the assembled `GenerateOptions`.
6. Follow the existing CLI pattern: check result.success, print errors, print completion message with duration and file count.

Preserve all existing CLI patterns:
- Dynamic import of stage module (lazy loading)
- `parseInt(options.chapter)` for chapter number
- Error handling with `process.exit(1)`
- Completion message with duration and file count

Do NOT modify any other commands (script, prompt, overlay, assemble, character). Only update the generate command.
  </action>
  <verify>
    `cd /Users/dondemetrius/Code/plasma/pipeline && pnpm typecheck` -- no type errors.
    `cd /Users/dondemetrius/Code/plasma/pipeline && pnpm dev -- generate --help` -- shows all new flags (--manual, --api, --import, --page, --pages, --approve, --notes).
    `cd /Users/dondemetrius/Code/plasma/pipeline && pnpm dev -- generate --manual -c 1 --dry-run` -- runs without error.
    `cd /Users/dondemetrius/Code/plasma/pipeline && pnpm test:run` -- all tests pass.
  </verify>
  <done>
    CLI generate subcommand accepts --manual, --api, --import, --page, --pages, --approve, --notes flags. Manual mode is the default. --import requires --page. Help text shows all options. All existing commands still work.
  </done>
</task>

</tasks>

<verification>
- `pnpm dev -- generate --manual -c 1` displays all 28 prompts from output/ch-01/prompts/ with copy-paste instructions
- `pnpm dev -- generate --manual -c 1 --pages 1-3` displays only pages 1, 2, 3
- Creating a test PNG and running `pnpm dev -- generate --manual -c 1 --import <test.png> --page 3` creates `output/ch-01/raw/ch01_p003_v1.png` and updates `output/ch-01/generation-log.json`
- Running the import again creates `ch01_p003_v2.png` (version auto-increment)
- `pnpm dev -- generate --approve ch01_p003_v1.png -c 1` marks that entry as approved in the manifest
- `pnpm test:run` -- all tests pass
- `pnpm typecheck` -- zero errors
</verification>

<success_criteria>
- Manual generate workflow is fully functional end-to-end
- User can display prompts, import images, and approve versions from CLI
- Every imported image is tracked in generation-log.json with prompt hash, model='manual', timestamp
- Version numbering auto-increments without overwriting previous versions
- All tests pass, typecheck passes
</success_criteria>

<output>
After completion, create `.planning/phases/03-image-generation-workflow/03-02-SUMMARY.md`
</output>
