---
phase: 03-image-generation-workflow
plan: 03
type: execute
wave: 3
depends_on:
  - 03-02
files_modified:
  - pipeline/src/generation/gemini-client.ts
  - pipeline/src/stages/generate.ts
  - pipeline/.env.example
  - pipeline/tests/generation/gemini-client.test.ts
  - pipeline/tests/stages/generate-api.test.ts
  - pipeline/package.json
autonomous: true
requirements:
  - IGEN-02
user_setup:
  - service: gemini-api
    why: "Automated image generation via Gemini API (IGEN-02)"
    env_vars:
      - name: GEMINI_API_KEY
        source: "Google AI Studio (https://aistudio.google.com) -> Get API Key -> Create API Key. Requires Cloud Billing setup for image generation (free tier does not support image output). Google provides $300 free credits for new billing accounts."
    dashboard_config:
      - task: "Enable Cloud Billing for image generation"
        location: "Google AI Studio -> Dashboard -> Usage and Billing -> Billing tab -> Set up Billing"

must_haves:
  truths:
    - "Running `generate --api -c 1 --pages 1` with a valid GEMINI_API_KEY generates an image and saves it to output/ch-01/raw/"
    - "API-generated images follow the same naming convention as manually imported images"
    - "API-generated images are recorded in the same generation-log.json manifest as manual imports"
    - "Rate limiting prevents 429 errors by adding configurable delay between API calls"
    - "Missing or invalid API key produces a clear error message before any API calls are attempted"
    - "Gemini client uses @google/genai SDK (not the deprecated @google/generative-ai)"
  artifacts:
    - path: "pipeline/src/generation/gemini-client.ts"
      provides: "Gemini API wrapper for image generation"
      exports: ["generateImage", "saveGeneratedImage", "validateApiKey"]
    - path: "pipeline/.env.example"
      provides: "Template showing required environment variables"
      contains: "GEMINI_API_KEY"
    - path: "pipeline/tests/generation/gemini-client.test.ts"
      provides: "Gemini client unit tests with mocked API"
      min_lines: 40
  key_links:
    - from: "pipeline/src/generation/gemini-client.ts"
      to: "@google/genai"
      via: "GoogleGenAI import"
      pattern: "import.*GoogleGenAI.*@google/genai"
    - from: "pipeline/src/stages/generate.ts"
      to: "pipeline/src/generation/gemini-client.ts"
      via: "generateImage import in API mode"
      pattern: "import.*generateImage.*gemini-client"
    - from: "pipeline/src/stages/generate.ts"
      to: "pipeline/src/generation/manifest.ts"
      via: "addEntry for API-generated images"
      pattern: "addEntry"
---

<objective>
Implement the automated Gemini API workflow that generates images directly from the CLI, using the @google/genai SDK with rate limiting, error handling, and full manifest integration.

Purpose: IGEN-02 upgrades the pipeline from manual copy-paste to a single CLI command (`generate --api -c 1`) that produces all panel images automatically. This layers on top of the manual workflow infrastructure (Plan 02) -- both workflows produce identically organized, identically tracked output.

Output: Working `generate --api` command with Gemini client, rate limiting, and manifest tracking. Plus .env.example for API key setup.
</objective>

<execution_context>
@/Users/dondemetrius/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dondemetrius/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-image-generation-workflow/03-01-SUMMARY.md
@.planning/phases/03-image-generation-workflow/03-02-SUMMARY.md
@.planning/phases/03-image-generation-workflow/03-RESEARCH.md

@pipeline/src/stages/generate.ts
@pipeline/src/generation/naming.ts
@pipeline/src/generation/manifest.ts
@pipeline/src/generation/image-import.ts
@pipeline/src/types/generation.ts
@pipeline/src/config/defaults.ts
@pipeline/src/config/paths.ts
@pipeline/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @google/genai SDK and create Gemini client</name>
  <files>
    pipeline/package.json
    pipeline/src/generation/gemini-client.ts
    pipeline/.env.example
    pipeline/tests/generation/gemini-client.test.ts
  </files>
  <action>
**Install the SDK:**
```bash
cd /Users/dondemetrius/Code/plasma/pipeline && pnpm add @google/genai
```

Verify `@google/generative-ai` is NOT in package.json (it should not be since it was never installed, but check). If present, remove it: `pnpm remove @google/generative-ai`.

**Create `pipeline/.env.example`:**
```
# Gemini API Key for automated image generation
# Get yours at: https://aistudio.google.com -> Get API Key
# Requires Cloud Billing for image generation (not available on free tier)
# Google provides $300 in free credits for new billing accounts
GEMINI_API_KEY=your-api-key-here

# Optional: Override default model (gemini-2.5-flash-image)
# GEMINI_MODEL=gemini-3-pro-image-preview
```

Ensure `.env` is in the project root `.gitignore`. Check `pipeline/.gitignore` too -- if neither exists for pipeline/, add `.env` to the pipeline `.gitignore` or the project root one.

**Create `pipeline/src/generation/gemini-client.ts`:**

Export `GeminiImageResult` interface:
```typescript
export interface GeminiImageResult {
  imageBuffer: Buffer;
  mimeType: string;
}
```

Export `validateApiKey(apiKey: string | undefined): string` function:
- If apiKey is undefined or empty string, throw Error with message: "GEMINI_API_KEY is not set. Set it in pipeline/.env or as an environment variable. Get a key at https://aistudio.google.com"
- Return the trimmed key.

Export `generateImage(opts)` function:
```
opts: {
  prompt: string;
  model?: string;       // defaults to DEFAULT_GEMINI_MODEL from defaults.ts
  aspectRatio?: string; // defaults to DEFAULT_ASPECT_RATIO from defaults.ts
  apiKey: string;
}
returns: Promise<GeminiImageResult>
```

Implementation:
1. Import `GoogleGenAI` from `@google/genai`.
2. Instantiate: `const ai = new GoogleGenAI({ apiKey: opts.apiKey })`.
3. Call `ai.models.generateContent()` with:
   - `model`: opts.model or DEFAULT_GEMINI_MODEL
   - `contents`: opts.prompt
   - `config.responseModalities`: `['TEXT', 'IMAGE']`
4. Extract image from response: iterate `response.candidates[0].content.parts`, find part with `inlineData`.
5. Decode: `Buffer.from(part.inlineData.data, 'base64')`.
6. Return `{ imageBuffer, mimeType: part.inlineData.mimeType ?? 'image/png' }`.
7. If no image part found, throw Error: "No image data in Gemini response. The model may not support image generation with the current API key tier."

Export `saveGeneratedImage(result: GeminiImageResult, destPath: string): Promise<void>`:
- Write imageBuffer to destPath using `writeFile` from `node:fs/promises`.

Export `sleep(ms: number): Promise<void>` -- simple `new Promise(resolve => setTimeout(resolve, ms))` for rate limiting between requests.

**Create `pipeline/tests/generation/gemini-client.test.ts`:**

Since we cannot make real Gemini API calls in tests, test the non-API parts:

1. `validateApiKey` throws on undefined
2. `validateApiKey` throws on empty string
3. `validateApiKey` returns trimmed key for valid input
4. `saveGeneratedImage` writes buffer to disk correctly (use temp dir, verify file exists and content matches)
5. `sleep` resolves after approximately the specified delay (test with 50ms, verify elapsed >= 50ms)

For `generateImage` itself, create a test that verifies the function signature and error handling:
6. `generateImage` throws meaningful error when API call fails (mock GoogleGenAI to throw)
7. `generateImage` throws when response has no image parts (mock GoogleGenAI to return text-only response)

Use `vi.mock('@google/genai')` to mock the SDK for API-dependent tests. The mock should return a configurable response object so you can test both success and failure paths.

Mock pattern:
```typescript
vi.mock('@google/genai', () => ({
  GoogleGenAI: vi.fn().mockImplementation(() => ({
    models: {
      generateContent: vi.fn(),
    },
  })),
}));
```

Set the mock's return value per test to simulate different API responses.
  </action>
  <verify>
    `cd /Users/dondemetrius/Code/plasma/pipeline && pnpm test:run -- tests/generation/gemini-client.test.ts` -- all tests pass.
    `cd /Users/dondemetrius/Code/plasma/pipeline && pnpm typecheck` -- no type errors.
    Verify `@google/genai` appears in package.json dependencies.
    Verify `.env.example` exists in pipeline/.
    Verify `.env` is in .gitignore.
  </verify>
  <done>
    Gemini client wrapper created with generateImage, saveGeneratedImage, validateApiKey, sleep exports. @google/genai installed. .env.example created. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire API workflow into generate stage with rate limiting and batch generation</name>
  <files>
    pipeline/src/stages/generate.ts
    pipeline/tests/stages/generate-api.test.ts
  </files>
  <action>
**Update `pipeline/src/stages/generate.ts` to implement the API workflow branch:**

In the `runGenerate` function, update the `mode === 'api'` branch (currently a placeholder from Plan 02):

1. **Load API key:** Read `process.env.GEMINI_API_KEY`. If not set, attempt to read from `pipeline/.env` using a simple `readFileSync` + line parsing (do NOT add dotenv as a dependency -- keep it minimal with manual parsing: read file, split by newlines, find `GEMINI_API_KEY=...` line, extract value). Call `validateApiKey()` on the result. If validation fails, return StageResult with success=false and the error message.

2. **Load prompts:** Read all `.txt` files from the prompts directory (`PATHS.chapterOutput(chapter).prompts`), sorted naturally. If `options.pages` is set, filter to only those page numbers.

3. **Load existing manifest:** Call `loadManifest(chapterDir, chapter)`.

4. **Batch generate with rate limiting:**
   For each prompt file:
   a. Extract page number from filename (e.g., `page-03.txt` -> 3)
   b. Read prompt text
   c. Determine next version via `nextVersion(rawDir, chapter, page)`
   d. Build destination filename via `panelImageFilename(chapter, page, version)`
   e. Log: `[generate] Page ${page} (v${version}) -- calling Gemini API...`
   f. Call `generateImage({ prompt, model: options.model, apiKey })`
   g. Call `saveGeneratedImage(result, destPath)`
   h. Build GenerationLogEntry with: imageFile, promptFile (relative), promptHash (from hashPrompt), model (options.model or DEFAULT_GEMINI_MODEL), timestamp, version, approved: false, promptText (full prompt for traceability)
   i. Call `addEntry(chapterDir, manifest, entry)`
   j. Log: `[generate] Page ${page} -> ${filename} (${result.mimeType})`
   k. Wait `DEFAULT_RATE_LIMIT_DELAY_MS` between requests via `sleep()` (skip delay after last image)

5. **Error handling per page:** Wrap each page's generation in try/catch. On error:
   - If error message contains "429" or "RESOURCE_EXHAUSTED": log rate limit warning, increase delay to `delay * 2` (exponential backoff), retry up to 2 times before skipping
   - If error message contains "permission" or "403": log API access error with setup instructions, abort remaining pages (likely a billing issue, retrying won't help)
   - Otherwise: log error, continue with next page

6. **Summary:** After all pages, log:
   ```
   [generate] Complete: {success}/{total} pages generated, {failed} failed
   [generate] Images saved to: output/ch-NN/raw/
   [generate] Manifest updated: output/ch-NN/generation-log.json
   ```

7. Return StageResult with outputFiles listing all successfully generated image paths.

**Also add .env file reading utility** -- create a small helper function `loadEnvFile(envPath: string): Record<string, string>` at the top of the generate stage file (or in a private function within generate.ts). It should:
- Read the file with readFileSync, return empty object if file doesn't exist
- Split by newlines, skip comments (#) and empty lines
- Parse `KEY=value` pairs, trim whitespace
- Return a simple key-value object

This avoids adding dotenv as a dependency while still supporting .env files.

**Create `pipeline/tests/stages/generate-api.test.ts`:**

Test the API workflow integration:
1. API mode with valid mock response creates image file in raw/ and updates manifest
2. API mode with --pages flag only generates specified pages
3. API mode with missing API key returns success=false with descriptive error
4. API mode handles per-page errors gracefully (continues with remaining pages)
5. Rate limiting: verify sleep is called between page generations (mock sleep)
6. Generated entries in manifest have correct model name, prompt hash, and timestamp

Mock both `@google/genai` and the `sleep` function. Use temp directories for file I/O.
  </action>
  <verify>
    `cd /Users/dondemetrius/Code/plasma/pipeline && pnpm test:run -- tests/stages/generate-api.test.ts` -- all tests pass.
    `cd /Users/dondemetrius/Code/plasma/pipeline && pnpm test:run` -- ALL tests pass (existing + all new Phase 3 tests).
    `cd /Users/dondemetrius/Code/plasma/pipeline && pnpm typecheck` -- no type errors.
    `cd /Users/dondemetrius/Code/plasma/pipeline && pnpm dev -- generate --api -c 1 --dry-run` -- runs without error, shows what would be generated.
  </verify>
  <done>
    API workflow generates images via Gemini, saves to raw/ with correct naming, records in manifest, handles rate limits with exponential backoff, skips billing errors early, continues on per-page errors. Manual workflow from Plan 02 still works unchanged. All tests pass.
  </done>
</task>

</tasks>

<verification>
- `pnpm test:run` passes ALL tests (134 existing + all Phase 3 tests)
- `pnpm typecheck` passes with zero errors
- `@google/genai` is in package.json dependencies, `@google/generative-ai` is NOT
- `.env.example` exists in pipeline/ with GEMINI_API_KEY template
- `.env` is in .gitignore
- `pnpm dev -- generate --api -c 1 --dry-run` shows planned generation without making API calls
- API mode with no API key produces clear error message with setup instructions
- Both `--manual` and `--api` modes produce identically named, identically tracked output files
</verification>

<success_criteria>
- Automated Gemini API workflow generates images from a single CLI command
- Rate limiting prevents 429 errors with configurable delay and exponential backoff
- API key validation catches missing/invalid keys before batch generation
- Generated images follow ch01_p003_v1.png naming convention
- All API-generated images tracked in generation-log.json with model name, prompt hash, timestamp
- Manual and API workflows coexist without conflict -- same naming, same manifest, same file structure
</success_criteria>

<output>
After completion, create `.planning/phases/03-image-generation-workflow/03-03-SUMMARY.md`
</output>
