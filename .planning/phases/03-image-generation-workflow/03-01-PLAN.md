---
phase: 03-image-generation-workflow
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - pipeline/src/types/generation.ts
  - pipeline/src/types/index.ts
  - pipeline/src/generation/naming.ts
  - pipeline/src/generation/manifest.ts
  - pipeline/src/config/defaults.ts
  - pipeline/tests/generation/naming.test.ts
  - pipeline/tests/generation/manifest.test.ts
autonomous: true
requirements:
  - IGEN-03
  - IGEN-04

must_haves:
  truths:
    - "Panel image filenames follow the format ch01_p003_v1.png exactly"
    - "Filenames can be parsed back into chapter, page, version components"
    - "Next version number is determined by scanning existing files in a directory"
    - "Generation manifest loads from JSON, saves to JSON, and appends entries atomically"
    - "Prompt text is hashed with SHA-256 for traceability"
  artifacts:
    - path: "pipeline/src/types/generation.ts"
      provides: "GenerationLogEntry and GenerationManifest types"
      exports: ["GenerationLogEntry", "GenerationManifest"]
    - path: "pipeline/src/generation/naming.ts"
      provides: "Panel image naming: generate, parse, nextVersion"
      exports: ["panelImageFilename", "parsePanelImageFilename", "nextVersion"]
    - path: "pipeline/src/generation/manifest.ts"
      provides: "Generation log read/write/hash operations"
      exports: ["hashPrompt", "loadManifest", "saveManifest", "addEntry"]
    - path: "pipeline/tests/generation/naming.test.ts"
      provides: "Naming convention tests"
      min_lines: 40
    - path: "pipeline/tests/generation/manifest.test.ts"
      provides: "Manifest CRUD and hashing tests"
      min_lines: 40
  key_links:
    - from: "pipeline/src/generation/manifest.ts"
      to: "pipeline/src/types/generation.ts"
      via: "type imports"
      pattern: "import type.*GenerationManifest"
    - from: "pipeline/src/generation/manifest.ts"
      to: "pipeline/src/config/defaults.ts"
      via: "PIPELINE_VERSION import"
      pattern: "import.*PIPELINE_VERSION"
    - from: "pipeline/src/types/index.ts"
      to: "pipeline/src/types/generation.ts"
      via: "re-export"
      pattern: "export type.*generation"
---

<objective>
Create the foundational types, naming convention, and generation manifest modules for image generation -- the building blocks that both the manual and API workflows depend on.

Purpose: IGEN-03 (naming convention) and IGEN-04 (prompt-to-image tracking) are pure domain logic with clear input/output contracts, making them ideal TDD candidates. Building these first with tests ensures correctness before the workflow plans wire them together.

Output: Typed generation domain library (naming.ts, manifest.ts, types/generation.ts) with comprehensive tests.
</objective>

<execution_context>
@/Users/dondemetrius/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dondemetrius/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@pipeline/src/types/pipeline.ts
@pipeline/src/types/index.ts
@pipeline/src/config/defaults.ts
@pipeline/src/utils/fs.ts
@pipeline/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Generation types and panel image naming with TDD</name>
  <files>
    pipeline/src/types/generation.ts
    pipeline/src/types/index.ts
    pipeline/src/generation/naming.ts
    pipeline/tests/generation/naming.test.ts
  </files>
  <action>
**RED phase -- Write failing tests first:**

Create `pipeline/tests/generation/naming.test.ts` with tests for:

1. `panelImageFilename(1, 3, 1)` returns `"ch01_p003_v1.png"`
2. `panelImageFilename(12, 28, 3)` returns `"ch12_p028_v3.png"`
3. `panelImageFilename(1, 1, 1, 'jpg')` returns `"ch01_p001_v1.jpg"`
4. `parsePanelImageFilename("ch01_p003_v1.png")` returns `{ chapter: 1, page: 3, version: 1, filename: "ch01_p003_v1.png", extension: "png" }`
5. `parsePanelImageFilename("not-a-panel.png")` returns `null`
6. `parsePanelImageFilename("ch01_p003_v1.jpeg")` parses correctly (jpeg extension)
7. `nextVersion()` returns 1 for empty directory
8. `nextVersion()` returns 2 when v1 exists
9. `nextVersion()` returns 4 when v1, v2, v3 exist (not just increment from count -- use max)
10. `nextVersion()` returns 1 for non-existent directory

Use `vitest` with a temporary directory (created in beforeEach, cleaned in afterEach) for `nextVersion` tests. Use `node:fs` to create fake files in the temp dir.

Run tests -- they MUST fail (module not found).

**GREEN phase -- Implement:**

Create `pipeline/src/types/generation.ts`:
- `GenerationLogEntry` interface: `imageFile` (string), `promptFile` (string), `promptHash` (string), `model` (string), `timestamp` (string, ISO 8601), `version` (number), `approved` (boolean), `notes` (optional string), `promptText` (optional string -- stores full prompt for absolute traceability per research recommendation)
- `GenerationManifest` interface: `chapter` (number), `pipelineVersion` (string), `entries` (GenerationLogEntry[])
- `PanelImageName` interface: `chapter` (number), `page` (number), `version` (number), `filename` (string), `extension` (string)

Update `pipeline/src/types/index.ts` to re-export: `export type { GenerationLogEntry, GenerationManifest, PanelImageName } from './generation.js';`

Create `pipeline/src/generation/naming.ts`:
- `panelImageFilename(chapter, page, version, ext='png')`: pad chapter to 2 digits, page to 3 digits, return `ch${ch}_p${pg}_v${version}.${ext}`
- `parsePanelImageFilename(filename)`: regex match `/^ch(\d{2})_p(\d{3})_v(\d+)\.(png|jpg|jpeg|webp)$/`, return PanelImageName or null
- `nextVersion(rawDir, chapter, page)`: scan directory for matching prefix, find max version, return max+1. Return 1 if directory doesn't exist or no matches. Use `readdirSync`.

All imports use `.js` extensions (ESM convention). Use `import type` for type-only imports.

Run tests -- they MUST pass.

**REFACTOR:** Clean up if needed, ensure consistent JSDoc comments. Run tests again.
  </action>
  <verify>
    `cd /Users/dondemetrius/Code/plasma/pipeline && pnpm test:run -- tests/generation/naming.test.ts` -- all tests pass
  </verify>
  <done>
    panelImageFilename produces correct format, parsePanelImageFilename round-trips correctly, nextVersion auto-increments by scanning directory. 10+ tests green.
  </done>
</task>

<task type="auto">
  <name>Task 2: Generation manifest module with TDD</name>
  <files>
    pipeline/src/generation/manifest.ts
    pipeline/src/config/defaults.ts
    pipeline/tests/generation/manifest.test.ts
  </files>
  <action>
**RED phase -- Write failing tests first:**

Create `pipeline/tests/generation/manifest.test.ts` with tests for:

1. `hashPrompt("test prompt")` returns a 64-char hex string (SHA-256)
2. `hashPrompt` produces different hashes for different inputs
3. `hashPrompt` produces identical hashes for identical inputs (deterministic)
4. `loadManifest()` returns empty manifest when file doesn't exist (chapter number, PIPELINE_VERSION, empty entries array)
5. `loadManifest()` parses existing JSON manifest file correctly
6. `saveManifest()` writes valid JSON to disk
7. `saveManifest()` then `loadManifest()` round-trips correctly
8. `addEntry()` appends an entry and persists to disk
9. `addEntry()` called twice produces manifest with 2 entries
10. `getApprovedEntry()` returns the approved version for a given page
11. `getApprovedEntry()` returns undefined when no approved version exists

Use temp directories for all file I/O tests. Create realistic test data matching the GenerationLogEntry interface.

Run tests -- they MUST fail.

**GREEN phase -- Implement:**

Create `pipeline/src/generation/manifest.ts`:
- `hashPrompt(promptText: string): string` -- `createHash('sha256').update(promptText, 'utf-8').digest('hex')` using `node:crypto`
- `loadManifest(chapterDir: string, chapter: number): Promise<GenerationManifest>` -- read `generation-log.json` from chapterDir, parse JSON, return. If file doesn't exist, return `{ chapter, pipelineVersion: PIPELINE_VERSION, entries: [] }`
- `saveManifest(chapterDir: string, manifest: GenerationManifest): Promise<void>` -- write JSON with 2-space indent to `generation-log.json`
- `addEntry(chapterDir: string, manifest: GenerationManifest, entry: GenerationLogEntry): Promise<void>` -- push entry to manifest.entries, call saveManifest
- `getApprovedEntry(manifest: GenerationManifest, page: number): GenerationLogEntry | undefined` -- find entry where `approved === true` and page matches (parse filename with parsePanelImageFilename). If multiple approved entries for same page, return the latest by timestamp.

Import PIPELINE_VERSION from `../config/defaults.js`. Import parsePanelImageFilename from `./naming.js`. All imports use `.js` extensions.

Add generation defaults to `pipeline/src/config/defaults.ts`:
- `DEFAULT_GEMINI_MODEL = 'gemini-2.5-flash-image'` (fast/cheap model for drafting)
- `DEFAULT_ASPECT_RATIO = '3:4'` (portrait manga pages)
- `DEFAULT_RATE_LIMIT_DELAY_MS = 2000` (2 seconds between API calls)

Run tests -- they MUST pass.

**REFACTOR:** Ensure consistent error handling, JSDoc on all exports. Run tests.
  </action>
  <verify>
    `cd /Users/dondemetrius/Code/plasma/pipeline && pnpm test:run -- tests/generation/manifest.test.ts` -- all tests pass.
    `cd /Users/dondemetrius/Code/plasma/pipeline && pnpm test:run` -- all existing + new tests pass (134+ existing + new).
    `cd /Users/dondemetrius/Code/plasma/pipeline && pnpm typecheck` -- no type errors.
  </verify>
  <done>
    Manifest module loads, saves, appends entries, and round-trips JSON correctly. Prompt hashing is deterministic SHA-256. Generation defaults exported. All tests green including pre-existing 134.
  </done>
</task>

</tasks>

<verification>
- `pnpm test:run` in pipeline/ passes all tests (134 existing + new naming + manifest tests)
- `pnpm typecheck` passes with zero errors
- `panelImageFilename(1, 3, 1)` produces `"ch01_p003_v1.png"` (verified by test)
- `parsePanelImageFilename` round-trips with `panelImageFilename` (verified by test)
- `loadManifest` + `saveManifest` round-trip JSON correctly (verified by test)
- `hashPrompt` produces deterministic SHA-256 hashes (verified by test)
- Types re-exported from `types/index.ts`
</verification>

<success_criteria>
- GenerationLogEntry, GenerationManifest, PanelImageName types exist and are exported
- panelImageFilename, parsePanelImageFilename, nextVersion functions work with tests
- hashPrompt, loadManifest, saveManifest, addEntry, getApprovedEntry functions work with tests
- Generation defaults (model, aspect ratio, rate limit) exported from defaults.ts
- All tests pass, typecheck passes
</success_criteria>

<output>
After completion, create `.planning/phases/03-image-generation-workflow/03-01-SUMMARY.md`
</output>
